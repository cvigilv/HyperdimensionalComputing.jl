<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>What&#39;s the Dollar of Mexico? · HyperdimensionalComputing.jl</title><script data-outdated-warner src="../../assets/warner.js"></script><link rel="canonical" href="https://cvigilv.github.io/HyperdimensionalComputing.jl/examples/whats-the-dollar-of-mexico/"/><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.039/juliamono-regular.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.11/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../../">HyperdimensionalComputing.jl</a></span></div><form class="docs-search" action="../../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../../">HyperdimensionalComputing.jl</a></li><li><span class="tocitem">Examples</span><ul><li><a class="tocitem" href="../introduction-to-hdc/">Introduction to HDC</a></li><li class="is-active"><a class="tocitem" href>What&#39;s the Dollar of Mexico?</a><ul class="internal"><li><a class="tocitem" href="#The-Big-Picture:-Why-High-Dimensional-Vectors?"><span>The Big Picture: Why High-Dimensional Vectors?</span></a></li><li><a class="tocitem" href="#The-Two-Fundamental-Operations"><span>The Two Fundamental Operations</span></a></li><li><a class="tocitem" href="#Holistic-Encoding:-Representing-Complex-Concepts"><span>Holistic Encoding: Representing Complex Concepts</span></a></li><li><a class="tocitem" href="#The-Heart-of-the-Matter:-Mapping-Between-Concept-Spaces"><span>The Heart of the Matter: Mapping Between Concept Spaces</span></a></li><li><a class="tocitem" href="#The-IQ-Test:-&quot;United-States-is-to-Mexico-as-Dollar-is-to-what?&quot;"><span>The IQ Test: &quot;United States is to Mexico as Dollar is to what?&quot;</span></a></li><li><a class="tocitem" href="#Chaining-Mappings:-From-Swedish-to-English-to-Spanish"><span>Chaining Mappings: From Swedish to English to Spanish</span></a></li><li><a class="tocitem" href="#The-Deeper-Implications"><span>The Deeper Implications</span></a></li><li><a class="tocitem" href="#From-Variables-to-Prototypes"><span>From Variables to Prototypes</span></a></li><li><a class="tocitem" href="#Demonstrating-Robustness:-Multiple-Analogies"><span>Demonstrating Robustness: Multiple Analogies</span></a></li><li><a class="tocitem" href="#Exploring-the-Geometric-Properties"><span>Exploring the Geometric Properties</span></a></li><li><a class="tocitem" href="#The-Computational-Revolution"><span>The Computational Revolution</span></a></li><li><a class="tocitem" href="#Conclusion:-The-Future-of-Concept-Representation"><span>Conclusion: The Future of Concept Representation</span></a></li></ul></li></ul></li><li><a class="tocitem" href="../../api/">API</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Examples</a></li><li class="is-active"><a href>What&#39;s the Dollar of Mexico?</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>What&#39;s the Dollar of Mexico?</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/cvigilv/HyperdimensionalComputing.jl/blob/main/docs/src/examples/whats-the-dollar-of-mexico.jl#" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="What-We-Mean-When-We-Say-&quot;What&#39;s-the-Dollar-of-Mexico?&quot;:-Replicating-Kanerva&#39;s-Concept-Mapping"><a class="docs-heading-anchor" href="#What-We-Mean-When-We-Say-&quot;What&#39;s-the-Dollar-of-Mexico?&quot;:-Replicating-Kanerva&#39;s-Concept-Mapping">What We Mean When We Say &quot;What&#39;s the Dollar of Mexico?&quot;: Replicating Kanerva&#39;s Concept Mapping</a><a id="What-We-Mean-When-We-Say-&quot;What&#39;s-the-Dollar-of-Mexico?&quot;:-Replicating-Kanerva&#39;s-Concept-Mapping-1"></a><a class="docs-heading-anchor-permalink" href="#What-We-Mean-When-We-Say-&quot;What&#39;s-the-Dollar-of-Mexico?&quot;:-Replicating-Kanerva&#39;s-Concept-Mapping" title="Permalink"></a></h1><p>In 2010, Pentti Kanerva published a fascinating paper that explored how our brains might perform analogical reasoning using high-dimensional vector spaces. The paper&#39;s title comes from a deceptively simple question: &quot;What&#39;s the dollar of Mexico?&quot; — which we immediately understand to mean &quot;peso,&quot; even though Mexico doesn&#39;t literally have a &quot;dollar.&quot;</p><p>This kind of analogical thinking is so natural to us that we barely notice it, yet it reveals something profound about how our minds work. Today, we&#39;ll replicate Kanerva&#39;s key insights using Julia&#39;s HyperdimensionalComputing.jl package, showing how high-dimensional vectors can encode concepts and perform the kinds of mappings that enable analogical reasoning.</p><h2 id="The-Big-Picture:-Why-High-Dimensional-Vectors?"><a class="docs-heading-anchor" href="#The-Big-Picture:-Why-High-Dimensional-Vectors?">The Big Picture: Why High-Dimensional Vectors?</a><a id="The-Big-Picture:-Why-High-Dimensional-Vectors?-1"></a><a class="docs-heading-anchor-permalink" href="#The-Big-Picture:-Why-High-Dimensional-Vectors?" title="Permalink"></a></h2><p>Traditional computing works with small, precise representations — bytes, words, maybe 32 or 64 bits. But Kanerva argues that brain-like computing requires something fundamentally different: <strong>hyperdimensional vectors</strong> with tens of thousands of dimensions. These vectors have remarkable properties that make them suitable for modeling how we think about concepts and their relationships.</p><pre><code class="language-julia hljs">using HyperdimensionalComputing
using Random
Random.seed!(42)  # For reproducible results</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">Random.TaskLocalRNG()</code></pre><p>We&#39;ll work with 10,000-dimensional binary vectors, just like Kanerva&#39;s paper</p><pre><code class="language-julia hljs">const DIM = 10000

println(&quot;Working with $(DIM)-dimensional hyperdimensional vectors&quot;)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">Working with 10000-dimensional hyperdimensional vectors</code></pre><h2 id="The-Two-Fundamental-Operations"><a class="docs-heading-anchor" href="#The-Two-Fundamental-Operations">The Two Fundamental Operations</a><a id="The-Two-Fundamental-Operations-1"></a><a class="docs-heading-anchor-permalink" href="#The-Two-Fundamental-Operations" title="Permalink"></a></h2><p>Kanerva identifies two key operations that make hyperdimensional computing possible:</p><ol><li><strong>Binding</strong> (★): Combines two vectors to create something dissimilar to both</li><li><strong>Bundling</strong> ([...+...]): Combines multiple vectors to create their &quot;average&quot;</li></ol><p>In our Julia implementation, these correspond to multiplication (*) and addition (+):</p><p>Create some basic concept vectors</p><pre><code class="language-julia hljs">function create_concept(name::String)
    return BipolarHDV(DIM)
end</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">create_concept (generic function with 1 method)</code></pre><p>Let&#39;s create vectors for countries and their attributes</p><pre><code class="language-julia hljs">usa_vec = create_concept(&quot;USA&quot;)
mexico_vec = create_concept(&quot;Mexico&quot;)
sweden_vec = create_concept(&quot;Sweden&quot;)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">10000-element BipolarHDV:
  1
 -1
  1
 -1
  1
  1
  1
 -1
  1
  1
  ⋮
  1
 -1
 -1
  1
 -1
  1
 -1
  1
 -1</code></pre><p>Attributes</p><pre><code class="language-julia hljs">name_vec = create_concept(&quot;NAME&quot;)
capital_vec = create_concept(&quot;CAPITAL&quot;)
currency_vec = create_concept(&quot;CURRENCY&quot;)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">10000-element BipolarHDV:
 -1
 -1
 -1
  1
  1
 -1
 -1
  1
  1
  1
  ⋮
  1
 -1
  1
  1
 -1
  1
  1
 -1
  1</code></pre><p>Specific values</p><pre><code class="language-julia hljs">washington_vec = create_concept(&quot;Washington&quot;)
mexico_city_vec = create_concept(&quot;Mexico City&quot;)
stockholm_vec = create_concept(&quot;Stockholm&quot;)
dollar_vec = create_concept(&quot;Dollar&quot;)
peso_vec = create_concept(&quot;Peso&quot;)
krona_vec = create_concept(&quot;Krona&quot;)

println(&quot;Created concept vectors for countries, attributes, and values&quot;)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">Created concept vectors for countries, attributes, and values</code></pre><h2 id="Holistic-Encoding:-Representing-Complex-Concepts"><a class="docs-heading-anchor" href="#Holistic-Encoding:-Representing-Complex-Concepts">Holistic Encoding: Representing Complex Concepts</a><a id="Holistic-Encoding:-Representing-Complex-Concepts-1"></a><a class="docs-heading-anchor-permalink" href="#Holistic-Encoding:-Representing-Complex-Concepts" title="Permalink"></a></h2><p>The magic happens when we combine these vectors to represent complex concepts. A country isn&#39;t just a name — it&#39;s a bundle of attributes like capital city, currency, culture, etc. We can encode this holistically:</p><p>Encode the United States as a holistic vector US = (NAME * USA) + (CAPITAL * Washington) + (CURRENCY * Dollar)</p><pre><code class="language-julia hljs">us_encoded = (name_vec * usa_vec) + (capital_vec * washington_vec) + (currency_vec * dollar_vec)
println(&quot;US encoded vector size: &quot;, size(us_encoded))</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">US encoded vector size: (10000,)</code></pre><p>Encode Mexico similarly</p><pre><code class="language-julia hljs">mexico_encoded = (name_vec * mexico_vec) + (capital_vec * mexico_city_vec) + (currency_vec * peso_vec)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">10000-element BipolarHDV:
 -1
 -1
 -1
  1
  1
 -1
  1
  1
  1
 -1
  ⋮
 -1
  1
  1
 -1
 -1
 -1
 -1
 -1
  1</code></pre><p>And Sweden</p><pre><code class="language-julia hljs">sweden_encoded = (name_vec * sweden_vec) + (capital_vec * stockholm_vec) + (currency_vec * krona_vec)

println(&quot;Encoded three countries with their attributes&quot;)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">Encoded three countries with their attributes</code></pre><p>The beautiful property of this encoding is that we can extract information from it:</p><p>What&#39;s the currency of the US? We &quot;query&quot; by binding with the currency attribute</p><pre><code class="language-julia hljs">us_currency_query = us_encoded * currency_vec
println(&quot;\nQuerying: What&#39;s the currency of the US?&quot;)
println(&quot;Similarity to dollar: &quot;, round(similarity(us_currency_query, dollar_vec), digits=3))
println(&quot;Similarity to peso: &quot;, round(similarity(us_currency_query, peso_vec), digits=3))
println(&quot;Similarity to krona: &quot;, round(similarity(us_currency_query, krona_vec), digits=3))</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">
Querying: What&#39;s the currency of the US?
Similarity to dollar: 0.487
Similarity to peso: -0.01
Similarity to krona: 0.021</code></pre><h2 id="The-Heart-of-the-Matter:-Mapping-Between-Concept-Spaces"><a class="docs-heading-anchor" href="#The-Heart-of-the-Matter:-Mapping-Between-Concept-Spaces">The Heart of the Matter: Mapping Between Concept Spaces</a><a id="The-Heart-of-the-Matter:-Mapping-Between-Concept-Spaces-1"></a><a class="docs-heading-anchor-permalink" href="#The-Heart-of-the-Matter:-Mapping-Between-Concept-Spaces" title="Permalink"></a></h2><p>Now comes the really interesting part. Kanerva shows that we can create <strong>mapping vectors</strong> that transform one concept space into another. This is how we can answer &quot;What&#39;s the dollar of Mexico?&quot;</p><p>Create a mapping from US to Mexico</p><pre><code class="language-julia hljs">us_to_mexico_map = us_encoded * mexico_encoded

println(&quot;\nCreated mapping vector from US to Mexico&quot;)
println(&quot;Map vector size: &quot;, size(us_to_mexico_map))</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">
Created mapping vector from US to Mexico
Map vector size: (10000,)</code></pre><p>Now we can use this mapping to answer our question &quot;What&#39;s the dollar of Mexico?&quot;</p><pre><code class="language-julia hljs">dollar_mapped = dollar_vec * us_to_mexico_map

println(&quot;\nWhat&#39;s the dollar of Mexico?&quot;)
println(&quot;Similarity to peso: &quot;, round(similarity(dollar_mapped, peso_vec), digits=3))
println(&quot;Similarity to dollar: &quot;, round(similarity(dollar_mapped, dollar_vec), digits=3))
println(&quot;Similarity to krona: &quot;, round(similarity(dollar_mapped, krona_vec), digits=3))</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">
What&#39;s the dollar of Mexico?
Similarity to peso: 0.249
Similarity to dollar: -0.009
Similarity to krona: -0.006</code></pre><p>The mapping vector captures the relationship between the US and Mexico, and when we apply it to &quot;dollar,&quot; we get &quot;peso&quot;!</p><h2 id="The-IQ-Test:-&quot;United-States-is-to-Mexico-as-Dollar-is-to-what?&quot;"><a class="docs-heading-anchor" href="#The-IQ-Test:-&quot;United-States-is-to-Mexico-as-Dollar-is-to-what?&quot;">The IQ Test: &quot;United States is to Mexico as Dollar is to what?&quot;</a><a id="The-IQ-Test:-&quot;United-States-is-to-Mexico-as-Dollar-is-to-what?&quot;-1"></a><a class="docs-heading-anchor-permalink" href="#The-IQ-Test:-&quot;United-States-is-to-Mexico-as-Dollar-is-to-what?&quot;" title="Permalink"></a></h2><p>Let&#39;s implement Kanerva&#39;s famous IQ test example more explicitly:</p><p>The classic analogy: &quot;United States is to Mexico as Dollar is to what?&quot; This is asking: US : Mexico :: Dollar : ?</p><p>We can solve this by finding the mapping that takes US to Mexico and then applying it to Dollar</p><p>Method 1: Direct computation as shown in the paper If F maps Dollar to US, then F also maps Peso to Mexico So: F * Dollar = US and F * Peso = Mexico This gives us: US * Dollar = Mexico * Peso Therefore: Mexico * US * Dollar = Peso</p><pre><code class="language-julia hljs">answer1 = mexico_encoded * us_encoded * dollar_vec
println(&quot;\nIQ Test Answer (Method 1 - Direct computation):&quot;)
println(&quot;Similarity to peso: &quot;, round(similarity(answer1, peso_vec), digits=3))
println(&quot;Similarity to dollar: &quot;, round(similarity(answer1, dollar_vec), digits=3))
println(&quot;Similarity to krona: &quot;, round(similarity(answer1, krona_vec), digits=3))</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">
IQ Test Answer (Method 1 - Direct computation):
Similarity to peso: 0.249
Similarity to dollar: -0.009
Similarity to krona: -0.006</code></pre><p>Method 2: Using the mapping vector we computed earlier</p><pre><code class="language-julia hljs">answer2 = dollar_vec * us_to_mexico_map
println(&quot;\nIQ Test Answer (Method 2 - Using mapping vector):&quot;)
println(&quot;Similarity to peso: &quot;, round(similarity(answer2, peso_vec), digits=3))
println(&quot;Similarity to dollar: &quot;, round(similarity(answer2, dollar_vec), digits=3))
println(&quot;Similarity to krona: &quot;, round(similarity(answer2, krona_vec), digits=3))</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">
IQ Test Answer (Method 2 - Using mapping vector):
Similarity to peso: 0.249
Similarity to dollar: -0.009
Similarity to krona: -0.006</code></pre><h2 id="Chaining-Mappings:-From-Swedish-to-English-to-Spanish"><a class="docs-heading-anchor" href="#Chaining-Mappings:-From-Swedish-to-English-to-Spanish">Chaining Mappings: From Swedish to English to Spanish</a><a id="Chaining-Mappings:-From-Swedish-to-English-to-Spanish-1"></a><a class="docs-heading-anchor-permalink" href="#Chaining-Mappings:-From-Swedish-to-English-to-Spanish" title="Permalink"></a></h2><p>One of the most elegant aspects of Kanerva&#39;s approach is that mappings can be chained. We can translate concepts from Swedish to English to Spanish:</p><p>Create mapping from Sweden to US</p><pre><code class="language-julia hljs">sweden_to_us_map = sweden_encoded * us_encoded</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">10000-element BipolarHDV:
  1
 -1
  1
  1
 -1
 -1
  1
  1
 -1
  1
  ⋮
 -1
  1
  1
  1
 -1
  1
 -1
 -1
 -1</code></pre><p>Chain the mappings: Sweden -&gt; US -&gt; Mexico</p><pre><code class="language-julia hljs">sweden_to_mexico_map = sweden_to_us_map * us_to_mexico_map</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">10000-element BipolarHDV:
  1
 -1
 -1
  1
  1
  1
  1
 -1
  1
  1
  ⋮
  1
  1
 -1
 -1
  1
  1
  1
 -1
  1</code></pre><p>This should be equivalent to the direct mapping</p><pre><code class="language-julia hljs">direct_sweden_to_mexico = sweden_encoded * mexico_encoded

println(&quot;\nChained mapping similarity to direct mapping: &quot;)
println(round(similarity(sweden_to_mexico_map, direct_sweden_to_mexico), digits=3))</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">
Chained mapping similarity to direct mapping:
1.0</code></pre><p>Test the chained mapping</p><pre><code class="language-julia hljs">krona_to_peso = krona_vec * sweden_to_mexico_map
println(&quot;\nWhat&#39;s the krona of Mexico (via US)?&quot;)
println(&quot;Similarity to peso: &quot;, round(similarity(krona_to_peso, peso_vec), digits=3))
println(&quot;Similarity to dollar: &quot;, round(similarity(krona_to_peso, dollar_vec), digits=3))
println(&quot;Similarity to krona: &quot;, round(similarity(krona_to_peso, krona_vec), digits=3))</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">
What&#39;s the krona of Mexico (via US)?
Similarity to peso: 0.248
Similarity to dollar: -0.015
Similarity to krona: 0.013</code></pre><h2 id="The-Deeper-Implications"><a class="docs-heading-anchor" href="#The-Deeper-Implications">The Deeper Implications</a><a id="The-Deeper-Implications-1"></a><a class="docs-heading-anchor-permalink" href="#The-Deeper-Implications" title="Permalink"></a></h2><p>What we&#39;ve demonstrated here is remarkable: using simple vector operations on high-dimensional spaces, we can:</p><ol><li><strong>Encode complex concepts</strong> holistically</li><li><strong>Extract specific information</strong> from these encodings</li><li><strong>Create mappings</strong> between different concept spaces</li><li><strong>Perform analogical reasoning</strong> through vector arithmetic</li><li><strong>Chain mappings</strong> to traverse multiple concept spaces</li></ol><p>The key insight is that the high dimensionality gives us the space we need for these operations to work reliably. In low-dimensional spaces, the noise would overwhelm the signal, but in 10,000 dimensions, the geometric properties work in our favor.</p><h2 id="From-Variables-to-Prototypes"><a class="docs-heading-anchor" href="#From-Variables-to-Prototypes">From Variables to Prototypes</a><a id="From-Variables-to-Prototypes-1"></a><a class="docs-heading-anchor-permalink" href="#From-Variables-to-Prototypes" title="Permalink"></a></h2><p>One of Kanerva&#39;s most profound observations is about how this differs from traditional symbolic AI. Instead of using abstract variables, we use <strong>prototypes</strong> — concrete examples that serve as templates for understanding new situations. When we ask &quot;What&#39;s the dollar of Mexico?&quot;, we&#39;re not using an abstract concept of &quot;currency&quot;; we&#39;re using the specific dollar as a prototype to understand peso.</p><p>Let&#39;s demonstrate this with a more complex example</p><pre><code class="language-julia hljs">function create_country_profile(name, capital, currency, population, continent)
    name_attr = create_concept(&quot;NAME&quot;)
    capital_attr = create_concept(&quot;CAPITAL&quot;)
    currency_attr = create_concept(&quot;CURRENCY&quot;)
    population_attr = create_concept(&quot;POPULATION&quot;)
    continent_attr = create_concept(&quot;CONTINENT&quot;)

    return (name_attr * create_concept(name)) +
           (capital_attr * create_concept(capital)) +
           (currency_attr * create_concept(currency)) +
           (population_attr * create_concept(population)) +
           (continent_attr * create_concept(continent))
end</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">create_country_profile (generic function with 1 method)</code></pre><p>Create rich country profiles</p><pre><code class="language-julia hljs">france = create_country_profile(&quot;France&quot;, &quot;Paris&quot;, &quot;Euro&quot;, &quot;Large&quot;, &quot;Europe&quot;)
japan = create_country_profile(&quot;Japan&quot;, &quot;Tokyo&quot;, &quot;Yen&quot;, &quot;Large&quot;, &quot;Asia&quot;)
brazil = create_country_profile(&quot;Brazil&quot;, &quot;Brasilia&quot;, &quot;Real&quot;, &quot;Large&quot;, &quot;South America&quot;)

println(&quot;\nCreated rich country profiles with multiple attributes&quot;)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">
Created rich country profiles with multiple attributes</code></pre><p>Create a mapping from France to Japan</p><pre><code class="language-julia hljs">france_to_japan_map = france * japan</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">10000-element BipolarHDV:
  1
  1
  1
 -1
  1
 -1
  1
  1
 -1
  1
  ⋮
  1
 -1
 -1
 -1
  1
 -1
 -1
  1
 -1</code></pre><p>What&#39;s the Euro of Japan?</p><pre><code class="language-julia hljs">euro_concept = create_concept(&quot;Euro&quot;)
euro_mapped_to_japan = euro_concept * france_to_japan_map
yen_concept = create_concept(&quot;Yen&quot;)

println(&quot;\nWhat&#39;s the Euro of Japan?&quot;)
println(&quot;Similarity to Yen: &quot;, round(similarity(euro_mapped_to_japan, yen_concept), digits=3))</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">
What&#39;s the Euro of Japan?
Similarity to Yen: 0.005</code></pre><h2 id="Demonstrating-Robustness:-Multiple-Analogies"><a class="docs-heading-anchor" href="#Demonstrating-Robustness:-Multiple-Analogies">Demonstrating Robustness: Multiple Analogies</a><a id="Demonstrating-Robustness:-Multiple-Analogies-1"></a><a class="docs-heading-anchor-permalink" href="#Demonstrating-Robustness:-Multiple-Analogies" title="Permalink"></a></h2><p>Let&#39;s test our system with multiple analogies to show its robustness:</p><p>Test multiple currency analogies</p><pre><code class="language-julia hljs">println(&quot;\n=== Testing Multiple Currency Analogies ===&quot;)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">
=== Testing Multiple Currency Analogies ===</code></pre><p>France to Japan currency mapping</p><pre><code class="language-julia hljs">france_currency_query = france * currency_vec
japan_currency_query = japan * currency_vec

println(&quot;France currency similarity to Euro: &quot;, round(similarity(france_currency_query, euro_concept), digits=3))
println(&quot;Japan currency similarity to Yen: &quot;, round(similarity(japan_currency_query, yen_concept), digits=3))</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">France currency similarity to Euro: 0.009
Japan currency similarity to Yen: -0.009</code></pre><p>Cross-mapping test: What&#39;s the Yen of France?</p><pre><code class="language-julia hljs">yen_mapped_to_france = yen_concept * (japan * france)
println(&quot;What&#39;s the Yen of France?&quot;)
println(&quot;Similarity to Euro: &quot;, round(similarity(yen_mapped_to_france, euro_concept), digits=3))</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">What&#39;s the Yen of France?
Similarity to Euro: 0.005</code></pre><h2 id="Exploring-the-Geometric-Properties"><a class="docs-heading-anchor" href="#Exploring-the-Geometric-Properties">Exploring the Geometric Properties</a><a id="Exploring-the-Geometric-Properties-1"></a><a class="docs-heading-anchor-permalink" href="#Exploring-the-Geometric-Properties" title="Permalink"></a></h2><p>One of the key insights from Kanerva&#39;s work is that these operations preserve certain geometric properties. Let&#39;s explore this:</p><p>Check that binding preserves distances</p><pre><code class="language-julia hljs">test_vec1 = create_concept(&quot;Test1&quot;)
test_vec2 = create_concept(&quot;Test2&quot;)
binding_vec = create_concept(&quot;Binder&quot;)

original_similarity = similarity(test_vec1, test_vec2)
bound_similarity = similarity(test_vec1 * binding_vec, test_vec2 * binding_vec)

println(&quot;\n=== Geometric Properties ===&quot;)
println(&quot;Original similarity: &quot;, round(original_similarity, digits=3))
println(&quot;Similarity after binding: &quot;, round(bound_similarity, digits=3))
println(&quot;Distance preservation: &quot;, round(abs(original_similarity - bound_similarity), digits=3))</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">
=== Geometric Properties ===
Original similarity: -0.008
Similarity after binding: -0.008
Distance preservation: 0.0</code></pre><h2 id="The-Computational-Revolution"><a class="docs-heading-anchor" href="#The-Computational-Revolution">The Computational Revolution</a><a id="The-Computational-Revolution-1"></a><a class="docs-heading-anchor-permalink" href="#The-Computational-Revolution" title="Permalink"></a></h2><p>This approach represents a fundamental shift in how we think about computation and cognition. Instead of the rigid, symbolic representations of traditional AI, hyperdimensional computing offers a more fluid, analogical approach that mirrors how humans naturally think.</p><p>Let&#39;s demonstrate with a final complex example</p><pre><code class="language-julia hljs">println(&quot;\n=== Final Complex Example: Multi-level Analogies ===&quot;)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">
=== Final Complex Example: Multi-level Analogies ===</code></pre><p>Create a hierarchical concept structure</p><pre><code class="language-julia hljs">animal_attr = create_concept(&quot;ANIMAL&quot;)
habitat_attr = create_concept(&quot;HABITAT&quot;)
diet_attr = create_concept(&quot;DIET&quot;)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">10000-element BipolarHDV:
  1
 -1
  1
 -1
  1
  1
 -1
 -1
  1
  1
  ⋮
 -1
  1
  1
 -1
 -1
 -1
 -1
 -1
 -1</code></pre><p>Animals</p><pre><code class="language-julia hljs">lion_concept = create_concept(&quot;Lion&quot;)
shark_concept = create_concept(&quot;Shark&quot;)
eagle_concept = create_concept(&quot;Eagle&quot;)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">10000-element BipolarHDV:
 -1
  1
 -1
  1
  1
  1
 -1
 -1
  1
 -1
  ⋮
  1
  1
 -1
  1
  1
  1
  1
 -1
 -1</code></pre><p>Habitats</p><pre><code class="language-julia hljs">land_concept = create_concept(&quot;Land&quot;)
ocean_concept = create_concept(&quot;Ocean&quot;)
sky_concept = create_concept(&quot;Sky&quot;)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">10000-element BipolarHDV:
  1
 -1
  1
  1
 -1
 -1
  1
  1
  1
  1
  ⋮
 -1
  1
 -1
  1
  1
  1
  1
 -1
  1</code></pre><p>Diets</p><pre><code class="language-julia hljs">carnivore_concept = create_concept(&quot;Carnivore&quot;)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">10000-element BipolarHDV:
 -1
  1
 -1
  1
 -1
  1
  1
 -1
 -1
 -1
  ⋮
 -1
 -1
  1
 -1
  1
  1
 -1
 -1
 -1</code></pre><p>Create animal profiles</p><pre><code class="language-julia hljs">lion_profile = (animal_attr * lion_concept) + (habitat_attr * land_concept) + (diet_attr * carnivore_concept)
shark_profile = (animal_attr * shark_concept) + (habitat_attr * ocean_concept) + (diet_attr * carnivore_concept)
eagle_profile = (animal_attr * eagle_concept) + (habitat_attr * sky_concept) + (diet_attr * carnivore_concept)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">10000-element BipolarHDV:
  1
 -1
 -1
 -1
  1
  1
 -1
  1
 -1
  1
  ⋮
  1
 -1
 -1
  1
 -1
 -1
  1
 -1
  1</code></pre><p>Create analogical mappings</p><pre><code class="language-julia hljs">land_to_ocean_map = lion_profile * shark_profile
ocean_to_sky_map = shark_profile * eagle_profile</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">10000-element BipolarHDV:
 -1
 -1
  1
 -1
 -1
 -1
  1
 -1
  1
 -1
  ⋮
  1
  1
 -1
  1
  1
 -1
  1
  1
  1</code></pre><p>Chain the mappings: What&#39;s the lion of the sky?</p><pre><code class="language-julia hljs">lion_of_sky = lion_concept * land_to_ocean_map * ocean_to_sky_map
direct_lion_to_eagle = lion_concept * (lion_profile * eagle_profile)

println(&quot;What&#39;s the lion of the sky (chained mapping)?&quot;)
println(&quot;Similarity to eagle: &quot;, round(similarity(lion_of_sky, eagle_concept), digits=3))
println(&quot;Direct lion-to-eagle mapping similarity: &quot;, round(similarity(direct_lion_to_eagle, eagle_concept), digits=3))</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">What&#39;s the lion of the sky (chained mapping)?
Similarity to eagle: 0.26
Direct lion-to-eagle mapping similarity: 0.26</code></pre><h2 id="Conclusion:-The-Future-of-Concept-Representation"><a class="docs-heading-anchor" href="#Conclusion:-The-Future-of-Concept-Representation">Conclusion: The Future of Concept Representation</a><a id="Conclusion:-The-Future-of-Concept-Representation-1"></a><a class="docs-heading-anchor-permalink" href="#Conclusion:-The-Future-of-Concept-Representation" title="Permalink"></a></h2><p>Kanerva&#39;s work points toward a fundamentally different way of thinking about computation and cognition. The HyperdimensionalComputing.jl package makes these ideas accessible and practical. As we&#39;ve seen, with just a few lines of code, we can:</p><ul><li>Encode complex concepts holistically</li><li>Perform analogical reasoning through vector operations</li><li>Create mappings between different domains of knowledge</li><li>Chain these mappings to traverse conceptual spaces</li></ul><p>This approach has profound implications for AI systems that need to understand and reason about concepts in human-like ways. It suggests that the key to flexible, adaptive intelligence might not be in building bigger symbolic knowledge bases, but in learning to work with the geometric properties of high-dimensional spaces.</p><pre><code class="language-julia hljs">println(&quot;\n=== Summary ===&quot;)
println(&quot;Successfully demonstrated:&quot;)
println(&quot;✓ Holistic concept encoding&quot;)
println(&quot;✓ Analogical reasoning through vector operations&quot;)
println(&quot;✓ Concept mapping and chaining&quot;)
println(&quot;✓ Geometric property preservation&quot;)
println(&quot;✓ Multi-level analogical structures&quot;)
println(&quot;\nThe next time someone asks you &#39;What&#39;s the dollar of Mexico?&#39;, you&#39;ll know that&quot;)
println(&quot;your brain is performing sophisticated vector operations in a high-dimensional&quot;)
println(&quot;concept space — and thanks to Kanerva&#39;s insights and HyperdimensionalComputing.jl,&quot;)
println(&quot;we can now replicate some of that magic in our computers.&quot;)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">
=== Summary ===
Successfully demonstrated:
✓ Holistic concept encoding
✓ Analogical reasoning through vector operations
✓ Concept mapping and chaining
✓ Geometric property preservation
✓ Multi-level analogical structures

The next time someone asks you &#39;What&#39;s the dollar of Mexico?&#39;, you&#39;ll know that
your brain is performing sophisticated vector operations in a high-dimensional
concept space — and thanks to Kanerva&#39;s insights and HyperdimensionalComputing.jl,
we can now replicate some of that magic in our computers.</code></pre><hr/><p><em>This page was generated using <a href="https://github.com/fredrikekre/Literate.jl">Literate.jl</a>.</em></p></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../introduction-to-hdc/">« Introduction to HDC</a><a class="docs-footer-nextpage" href="../../api/">API »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.6 on <span class="colophon-date" title="Saturday 12 July 2025 20:27">Saturday 12 July 2025</span>. Using Julia version 1.11.6.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
